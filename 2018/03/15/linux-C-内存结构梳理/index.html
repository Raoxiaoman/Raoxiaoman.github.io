<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
    
  
  <link href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css">







  

<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">


  <link rel="manifest" href="/images/manifest.json">


  <meta name="msapplication-config" content="/images/browserconfig.xml">



  <meta name="keywords" content="linux,C++,">





  <link rel="alternate" href="/atom.xml" title="Raoxiaoman" type="application/atom+xml">






<meta name="description" content="前提最近复习了Linux内存管理以及C++的内存管理,这里做一个详细的梳理。 章节 内存的分页和分段 逻辑地址，线性地址以及虚拟地址之间的关系 linux内存分配算法:伙伴系统和slab linux 进程通信中共享内存技术（mmap和shm) C++程序进程地址空间,程序中各个变量与常量分别位于哪一个段 C++内存池技术  内存的分页和分段虚拟内存地址空间由来当直接让进程使用直接的物理内存时，会对">
<meta name="keywords" content="linux,C++">
<meta property="og:type" content="article">
<meta property="og:title" content="linux C++ 内存结构梳理">
<meta property="og:url" content="https://raoxiaoman.github.io/2018/03/15/linux-C-内存结构梳理/index.html">
<meta property="og:site_name" content="Raoxiaoman">
<meta property="og:description" content="前提最近复习了Linux内存管理以及C++的内存管理,这里做一个详细的梳理。 章节 内存的分页和分段 逻辑地址，线性地址以及虚拟地址之间的关系 linux内存分配算法:伙伴系统和slab linux 进程通信中共享内存技术（mmap和shm) C++程序进程地址空间,程序中各个变量与常量分别位于哪一个段 C++内存池技术  内存的分页和分段虚拟内存地址空间由来当直接让进程使用直接的物理内存时，会对">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://raoxiaoman.github.io/images/vm_addr.png">
<meta property="og:image" content="https://raoxiaoman.github.io/images/vm_addr_search.png">
<meta property="og:image" content="https://raoxiaoman.github.io/images/page_address.png">
<meta property="og:image" content="https://raoxiaoman.github.io/images/page_map.png">
<meta property="og:image" content="https://raoxiaoman.github.io/images/page_search.png">
<meta property="og:image" content="https://raoxiaoman.github.io/images/segment_search.png">
<meta property="og:image" content="https://raoxiaoman.github.io/images/segment_page_address.png">
<meta property="og:image" content="https://raoxiaoman.github.io/images/segment_and_page.png">
<meta property="og:image" content="https://raoxiaoman.github.io/images/segment_and_page_search.png">
<meta property="og:image" content="https://i.loli.net/2018/09/09/5b948e765ff0c.jpg">
<meta property="og:updated_time" content="2019-03-02T12:59:27.126Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="linux C++ 内存结构梳理">
<meta name="twitter:description" content="前提最近复习了Linux内存管理以及C++的内存管理,这里做一个详细的梳理。 章节 内存的分页和分段 逻辑地址，线性地址以及虚拟地址之间的关系 linux内存分配算法:伙伴系统和slab linux 进程通信中共享内存技术（mmap和shm) C++程序进程地址空间,程序中各个变量与常量分别位于哪一个段 C++内存池技术  内存的分页和分段虚拟内存地址空间由来当直接让进程使用直接的物理内存时，会对">
<meta name="twitter:image" content="https://raoxiaoman.github.io/images/vm_addr.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://raoxiaoman.github.io/2018/03/15/linux-C-内存结构梳理/">





  <title>linux C++ 内存结构梳理 | Raoxiaoman</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Raoxiaoman</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Viva La Viva</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://raoxiaoman.github.io/2018/03/15/linux-C-内存结构梳理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Raoxiaoman">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Raoxiaoman">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">linux C++ 内存结构梳理</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-15T11:05:12+08:00">
                2018-03-15
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/15/linux-C-内存结构梳理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/03/15/linux-C-内存结构梳理/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,598
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  19
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>最近复习了Linux内存管理以及C++的内存管理,这里做一个详细的梳理。</p>
<h2 id="章节"><a href="#章节" class="headerlink" title="章节"></a>章节</h2><ul>
<li>内存的分页和分段</li>
<li>逻辑地址，线性地址以及虚拟地址之间的关系</li>
<li>linux内存分配算法:伙伴系统和slab</li>
<li>linux 进程通信中共享内存技术（mmap和shm)</li>
<li>C++程序进程地址空间,程序中各个变量与常量分别位于哪一个段</li>
<li>C++内存池技术</li>
</ul>
<h2 id="内存的分页和分段"><a href="#内存的分页和分段" class="headerlink" title="内存的分页和分段"></a>内存的分页和分段</h2><h3 id="虚拟内存地址空间"><a href="#虚拟内存地址空间" class="headerlink" title="虚拟内存地址空间"></a>虚拟内存地址空间</h3><h4 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h4><p>当直接让进程使用直接的物理内存时，会对物理内存操作时会出现混乱。<br>比如进程 A 装在 0-30 的物理内层，在 29 处是一条 ADD 指令。而进程 B 装在 30-40 处第一条指令为 JMP 29. 没有使用虚拟内存的话，进程 B 将直接跳到进程 A 从而使两者程序都破坏掉。<br>&nbsp;<br>有两种解决这个问题：一种通过基址寄存器和界线寄存器形成地址空间，通过交换技术解决内存超载。另外一种就是基于分页的虚拟地址技术。</p>
<ol>
<li>交换技术：把一个进程完整调入内存运行一段时间，然后把他存回磁盘，空闲进程主要存储在磁盘上。缺点：当进程空间大于内存时，不能使用。</li>
<li>虚拟内存：把一个进程的一部分调入内存中运行，当内存没有空闲空间时，将新的覆盖旧的页，同时将旧 是写入磁盘。虚拟内存主要使用分页存储管理模式。</li>
</ol>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>在多任务操作系统中，每个进程都运行在属于自己的内存沙盘中。这个沙盘就是虚拟地址空间 (Virtual Address Space)，在 32 位模式下它是一个 4GB 的内存地址块。在 Linux 系统中, 内核进程和用户进程所占的虚拟内存比例是 1:3，而 Windows 系统为 2:2(通过设置 Large-Address-Aware Executables 标志也可为 1:3)。这并不意味着内核使用那么多物理内存，仅表示它可支配这部分地址空间，根据需要将其映射到物理内存。<br>  &nbsp;<br>  <img src="/images/vm_addr.png" alt=""></li>
<li>CPU 通过一个虚拟地址（virtual address,VA）来访问主存，这个虚拟地址在被送到主存之前会先转换成一个物理地址。将虚拟地址转换成物理地址的任务叫做地址翻译(translation)。地址翻译需要 CPU 硬件和操作系统之间的配合。CPU 芯片上叫做内存管理单元（Menory Management Unit, MMU）的专用硬件，利用存放在主存中的(段表)页表来动态翻译虚拟地址，该表的内容由操作系统管理。</li>
<li>虚拟地址通过页表 (Page Table) 映射到物理内存，页表由操作系统维护并被处理器引用。内核空间在页表中拥有较高特权级，因此用户态程序试图访问这些页时会导致一个页错误 (page fault)。在 Linux 中，内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存。内核代码和数据总是可寻址，随时准备处理中断和系统调用。与此相反，用户模式地址空间的映射随进程切换的发生而不断变化。<br>  &nbsp;<br>  <img src="/images/vm_addr_search.png" alt=""><br>在C++程序进程地址空间,程序中各个变量与常量分别位于哪一个段会详细的介绍虚拟地址空间(进程地址空间)的各个段信息</li>
</ul>
<h3 id="分页存储管理"><a href="#分页存储管理" class="headerlink" title="分页存储管理"></a>分页存储管理</h3><ol>
<li>基本思想<br>用户程序的地址空间被划分成若干固定大小的区域，称为 “页”，相应地，内存空间分成若干个物理块(页框)，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。 <ul>
<li>等分内存<br>页式存储管理将内存空间划分成等长的若干物理块，成为物理页面也成为物理块，每个物理块的大小一般取 2 的整数幂。内存的所有物理块从 0 开始编号，称作物理页号</li>
<li>逻辑地址<br>系统将程序的逻辑空间按照同样大小也划分成若干页面，称为逻辑页面也称为页。程序的各个逻辑页面从 0 开始依次编号，称作逻辑页号或相对页号。每个页面内从 0 开始编址，称为页内地址。程序中的逻辑地址由两部分组成：页号P和页内位移量W。</li>
</ul>
</li>
<li>分页存储管理的地址机构<br>&nbsp;<br><img src="/images/page_address.png" alt=""><br>页号的位数x，表示最多2的x次方个页，页内位移量的位数表示页的大小，若页内位移量的位数为y,即页的大小为2的y次方，页内地址从000000000000开始到2的y次方</li>
<li><p>内存分配<br>相邻的页面在内存中不一定相邻，即分配给程序的内存块之间不一定连续。对程序地址空间的分页是系统自动进行的，即对用户是透明的。由于页面尺寸为 2 的整数次幂，故相对地址中的高位部分即为页号，低位部分为页内地址。</p>
</li>
<li><p>页表<br>分页系统中，允许将进程的每一页离散地存储在内存的任一物理块中，为了能在内存中找到每个页面对应的物理块，系统为每个进程建立一张页表，用于记录进程逻辑页面与内存物理页面之间的对应关系。页表的作用是实现从页号到物理块号的地址映射，地址空间有多少页，该页表里就登记多少行，且按逻辑页的顺序排列，形如：<br>&nbsp;<br><img src="/images/page_map.png" alt=""></p>
</li>
<li><p>地址转换（MMU)<br>若给定一个逻辑地址为A，页面大小为 L，则页号 P=INT[A/L]，页内地址 W=A MOD L<br>&nbsp;<br><img src="/images/page_search.png" alt=""><br>根据上面的三个步骤可以很容易得到结果：物理地址 = 3 <em> 8 </em> 1024 + 9612 % 8192 = 25996</p>
</li>
<li><p>具有快表的地址变换机构<br>分页系统中，CPU 每次要存取一个数据，都要两次访问内存（访问页表、访问实际物理地址）。为提高地址变换速度，增设一个具有并行查询能力的特殊高速缓冲存储器，称为 “联想存储器” 或 “快表”，存放当前访问的页表项。</p>
</li>
<li><p>页面的共享与保护<br>当多个不同进程中需要有相同页面信息时，可以在主存中只保留一个副本，只要让这些进程各自的有关项中指向内存同一块号即可。同时在页表中设置相应的 “存取权限”，对不同进程的访问权限进行各种必要的限制。</p>
</li>
<li><p>页面置换：<br>当进程在物理内存中运行时，调用到不在物理内存中的虚拟页面时，MMU 注意到该页面没有被映射到物理内存，于是 cpu 陷入到操作系统，这个陷阱称为缺页中断，操作系统找到一个很少使用的页框且把他的内容写入磁盘备份。随后把需要访问的虚拟页面读到刚才回收的页框中，修改映射关系，然后重新启动引起陷阱的指令。<br>主要的页面置换算法有：<a href="/http://blog.csdn.net/wangsifu2009/article/details/6757352">页面置换算法</a></p>
</li>
</ol>
<h3 id="分段存储管理"><a href="#分段存储管理" class="headerlink" title="分段存储管理"></a>分段存储管理</h3><ol>
<li><p>基本思想<br>页面是主存物理空间中划分出来的等长的固定区域。分页方式的优点是页长固定，因而便于构造页表、易于管理，且不存在外碎片。但分页方式的缺点是页长与程序的逻辑大小不相关。例如，某个时刻一个子程序可能有一部分在主存中，另一部分则在辅存中。这不利于编程时的独立性，并给换入换出处理、存储保护和存储共享等操作造成麻烦。<br>另一种划分可寻址的存储空间的方法称为分段。段是按照程序的自然分界划分的长度可以动态改变的区域。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中（写 c 程序时会用到），并且每个程序可以有多个相同类型的段。<br>段表本身也是一个段，可以存在辅存中，但一般是驻留在主存中。将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。</p>
</li>
<li><p>分段地址结构<br>作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。例程序段、数据段等。每个段都从 0 开始编址，并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，因而各段长度不等。整个作业的地址空间是二维的。<br>在段式虚拟存储系统中，虚拟地址由段号和段内地址组成，虚拟地址到实存地址的变换通过段表来实现。每个程序设置一个段表，段表的每一个表项对应一个段，每个表项至少包括三个字段：有效位（指明该段是否已经调入主存）、段起址 (该段在实存中的首地址) 和段长（记录该段的实际长度）。</p>
</li>
<li><p>地址变换<br>针对每一个虚拟地址，存储管理部件首先以段号 S 为索引访问段表的第 S 个表项。若该表项的有效位为 1，则将虚拟地址的段内地址 D 与该表项的段长字段比较；若段内地址较大则说明地址越界，将产生地址越界中断；否则，将该表项的段起址与段内地址相加，求得主存实地址并访存。如果该表项的有效位为 0，则产生缺页中断，从辅存中调入该页，并修改段表。段式虚拟存储器虚实地址变换过程如图所示。<br>&nbsp;<br><img src="/images/segment_search.png" alt=""></p>
</li>
</ol>
<h3 id="段页式存储"><a href="#段页式存储" class="headerlink" title="段页式存储"></a>段页式存储</h3><ol>
<li><p>段页式存储管理的基本思想<br>段页式存储组织是分段式和分页式结合的存储组织方法，这样可充分利用分段管理和分页管理的优点。</p>
<ul>
<li>用分段方法来分配和管理虚拟存储器。程序的地址空间按逻辑单位分成基本独立的段，而每一段有自己的段名，再把每段分成固定大小的若干页。</li>
<li>用分页方法来分配和管理实存。即把整个主存分成与上述页大小相等的存储块，可装入作业的任何一页。程序对内存的调入或调出是按页进行的。但它又可按段实现共享和保护。</li>
<li>逻辑地址结构。一个逻辑地址用三个参数表示：段号 S；页号 P；页内地址 d。<br>&nbsp;<br><img src="/images/segment_page_address.png" alt=""></li>
<li>段表、页表、段表地址寄存器。为了进行地址转换，系统为每个作业建立一个段表，并且要为该作业段表中的每一个段建立一个页表。系统中有一个段表地址寄存器来指出作业的段表起始地址和段表长度。<br>&nbsp;<br><img src="/images/segment_and_page.png" alt=""></li>
</ul>
</li>
<li><p>一个逻辑地址为：基地址 x、段号 s、页号 p 和页内地址 d,求物理地址的过程<br> &nbsp;<br> <img src="/images/segment_and_page_search.png" alt=""></p>
</li>
</ol>
<p>在段页式系统中，为了便于实现地址变换，须配置一个段表寄存器，其中存放段表始址和段表长 TL。</p>
<ul>
<li>进行地址变换时，首先利用段号 S，将它与段表长 TL 进行比较。若 S小于TL，表示未越界</li>
<li>于是利用段表始址和段号来求出该段所对应的段表项在段表中的位置，从中得到该段的页表始址</li>
<li>利用逻辑地址中的段内页号 P 来获得对应页的页表项位置，从中读出该页所在的物理块号 b</li>
<li>再利用块号 b 和页内地址来构成物理地址。</li>
</ul>
<p>上图示出了段页式系统中的地址变换机构。在段页式系统中，为了获得一条指令或数据，须三次访问内存。第一次访问是访问内存中的段表，从中取得页表始址；第二次访问是访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；第三次访问才是真正从第二次访问所得的地址中，取出指令或数据。显然，这使访问内存的次数增加了近两倍。为了提高执行速度，在地址变换机构中增设一个高速缓冲寄存器。每次访问它时，都须同时利用段号和页号去检索高速缓存，若找到匹配的表项，便可从中得到相应页的物理块号，用来与页内地址一起形成物理地址；若未找到匹配表项，则仍须再三次访问内存。 </p>
<h2 id="逻辑地址，线性地址以及虚拟地址之间的关系"><a href="#逻辑地址，线性地址以及虚拟地址之间的关系" class="headerlink" title="逻辑地址，线性地址以及虚拟地址之间的关系"></a>逻辑地址，线性地址以及虚拟地址之间的关系</h2><p>在 Intel 32 位下，并且以代码段为例 (之所以不讲 64 位是因为在 64-bit long mode 下分段直接被禁用了，内存完全平坦，没什么可以讲的…)</p>
<ul>
<li>在 Intel 平台下，逻辑地址 (logical address) 是 selector:offset 这种形式，selector 是 CS 寄存器的值，offset 是 EIP 寄存器的值。<br>如果用 selector 去 GDT(全局描述符表) 里拿到 segment base address(段基址) 然后加上 offset(段内偏移)，这就得到了linear address。<br>这个过程称作段式内存管理。如果再把 linear address 切成四段，用前三段分别作为索引去 PGD、PMD、Page Table 里查表，最终就会得到一个页表项 (Page Table Entry)，那里面的值就是一页物理内存的起始地址，把它加上 linear address 切分之后第四段的内容 (又叫页内偏移) 就得到了最终的 physical address。这个过程称作页式内存管理。</li>
<li>virtual address，这是个什么东西？<br>其实在 Intel IA-32 手册里并没有提到这个术语，但是在内核的确是用到了这个概念，比如__va 和__pa 这两个宏定义。<br>看似神秘的 virtual address 究其本质就是程序里面使用的地址比如一个指针值，指针的本质就是 EIP 寄存器里的值，说直白点，virtual address 就是 EIP 寄存器的值。上面说过，logical address 由 selector 和 offset 两部分组成，offset 也是 EIP 寄存器的值，所以结论为：logical address 的 offset 正是 virtual address，它俩是一个东西。既然搞明白了 logical address 和 virtual address 的关系。<br>那么再来看下，linear address 和 virtual address 是什么关系。在上面讲到的段式内存管理中，Linux 内核会将 segment base address(段基址) 设成 0，于是就有 linear address = 0+offset，又因为 virtual address 就是 offset，所以算出的 linear address 在数值上等于 virtual address，注意，是数值上等于，它们之间是差了段基址的，只不过段基址为 0 罢了。网上很多资料认为逻辑地址是虚拟地址的别名，其实它们不是一个东西。还有很多资料把线性地址当作虚拟地址的别名，其实它们也不是一个东西，只是 Linux 在 x86 下将它们搞得数值相等而已，虽然值相等但是本质不同。</li>
</ul>
<h2 id="linux内存分配算法-伙伴系统和slab"><a href="#linux内存分配算法-伙伴系统和slab" class="headerlink" title="linux内存分配算法:伙伴系统和slab"></a>linux内存分配算法:伙伴系统和slab</h2><h3 id="外部内存锁片"><a href="#外部内存锁片" class="headerlink" title="外部内存锁片"></a>外部内存锁片</h3><p>外部内存碎片就是内存被分割成很小很小的一些块，这些块虽然是空闲的，但是因为是不连续的，小到无法使用。</p>
<h3 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h3><p>Linux 便是采用这著名的伙伴系统算法来解决外部碎片的问题。把所有的空闲页框分组为 11 块链表，每一块链表分别包含大小为1，2，4，8，16，32，64，128，256，512 和 1024 个连续的页框。对1024 个页框的最大请求对应着 4MB 大小的连续RAM 块。每一块的第一个页框的物理地址是该块大小的整数倍。例如，大小为 16个页框的块，其起始地址是 16 * 2^12 （2^12 = 4096，这是一个常规页的大小）的倍数。</p>
<p>假设要请求一个256（129~256）个页框的块。算法先在256个页框的链表中检查是否有一个空闲块。如果没有这样的块，算法会查找下一个更大的页块，也就是，在512个页框的链表中找一个空闲块。如果存在这样的块，内核就把512的页框分成两等分，一般用作满足需求，另一半则插入到256个页框的链表中。如果在512个页框的块链表中也没找到空闲块，就继续找更大的块——1024个页框的块。如果这样的块存在，内核就把1024个页框块的256个页框用作请求，然后剩余的768个页框中拿512个插入到512个页框的链表中，再把最后的256个插入到256个页框的链表中。如果1024个页框的链表还是空的，算法就放弃并发出错误信号。</p>
<p>简而言之，就是在分配内存时，首先从空闲的内存中搜索比申请的内存大的最小的内存块。如果这样的内存块存在，则将这块内存标记为“已用”，同时将该内存分配给应用程序。如果这样的内存不存在，则操作系统将寻找更大块的空闲内存，然后将这块内存平分成两部分，一部分返回给程序使用，另一部分作为空闲的内存块等待下一次被分配。</p>
<p>以上过程的逆过程就是页框块的释放过程，也是该算法名字的由来。</p>
<p>假设要释放一个256个页框的块，算法就把其插入到256个页框的链表中，然后检查与该内存相邻的内存，如果存在同样大小为256个页框的并且空闲的内存，就将这两块内存合并成512个页框，然后插入到512个页框的链表中，如果不存在，就没有后面的合并操作。然后再进一步检查，如果合并后的512个页框的内存存在大小为512个页框的相邻且空闲的内存，则将两者合并，然后插入到1024个页框的链表中。</p>
<p>简而言之，就是当程序释放内存时，操作系统首先将该内存回收，然后检查与该内存相邻的内存是否是同样大小并且同样处于空闲的状态，如果是，则将这两块内存合并，然后程序递归进行同样的检查。</p>
<h3 id="内部内存碎片"><a href="#内部内存碎片" class="headerlink" title="内部内存碎片"></a>内部内存碎片</h3><p>内部碎片是已经被分配出去（能明确指出属于哪个进程）的内存空间大于请求所需的内存空间，不能被利用的内存空间就是内部碎片。<br>为了有效的利用内存，使内存产生更少的外部碎片，要对内存分页，内存以页为单位来使用，最后一页往往装不满，于是形成了内部碎片</p>
<h3 id="slab高速缓存"><a href="#slab高速缓存" class="headerlink" title="slab高速缓存"></a>slab高速缓存</h3><p>通俗的讲，slab 就是专门为某一模块预先一次性申请一定数量的内存备用，当这个模块想要使用内存的时候，就不再需要从系统中分配内存了（因为从系统中申请内存的时间开销相对来说比较大），而是直接从预申请的内存中拿出一部分来使用，这样就提高了这个模块的内存申请速度。<br>条件：</p>
<ol>
<li>当某一子系统需要频繁地申请和释放内存时，使用 slab 才会合理一些。</li>
<li>利用 slab 申请的内存必须是大小固定的。</li>
</ol>
<p>Linux 内核提供了 slab 层（slab 分配器），其扮演了通用数据结构缓存层的角色。slab 层把不同的对象划分为所谓高速缓存组，其中每个高速缓存组都存放不同类型的对象，每种对象类型对应一个高速缓存。例如，一个高速缓存用于存放进程描述符，而另一个高速缓存存放索引节点对象，然后这些高速缓存又被划分为 slab。slab 由一个或多个物理上连续的页组成。一般情况下，slab 也就是仅仅由一页组成，每个高速缓存可以由多个 slab 组成。</p>
<p>slab 分配器把每一个请求的内存称之为对象。每个 slab 都包含一些对象成员，这里的对象指的是被缓存的数据结构。每个 slab 处于三种状态之一：满、部分满或空。一个满的 slab 没有空闲的对象（slab 中的对象都已被分配）。一个空的 slab 没有分配出任何对象（slab 中所有对象都是空闲的）。一个部分满的 slab 有一些对象已分配出去，有些对象还空闲着。当内核的某一部分需要一个新的对象时，先从部分满的 slab 中进行分配，如果没有部分满的 slab，就从空的 slab 中进行分配。如果没有空的 slab，就要创建一个 slab 了。<br>高速缓存、slab、对象之间的关系：<br>&nbsp;<br><img src="https://i.loli.net/2018/09/09/5b948e765ff0c.jpg" alt="20140514202314640.jpg"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/wenqian1991/article/details/27968779" target="_blank" rel="noopener">linux-伙伴算法</a><br><a href="https://blog.csdn.net/wenqian1991/article/details/25652147" target="_blank" rel="noopener">linux-slab</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/linux/" rel="tag"># linux</a>
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/08/wisckey阅读/" rel="prev" title="wisckey阅读">
                wisckey阅读 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="hypercomments_widget"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.jpeg" alt="Raoxiaoman">
            
              <p class="site-author-name" itemprop="name">Raoxiaoman</p>
              <p class="site-description motion-element" itemprop="description">linux C++ Python Java</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/raoxiaoman" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="raoxiaohuihui@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-globe"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
         <div class="music163player">
             <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28524471&auto=0&height=66">
             </iframe>
        </div>

      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前提"><span class="nav-number">1.</span> <span class="nav-text">前提</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#章节"><span class="nav-number">2.</span> <span class="nav-text">章节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存的分页和分段"><span class="nav-number">3.</span> <span class="nav-text">内存的分页和分段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟内存地址空间"><span class="nav-number">3.1.</span> <span class="nav-text">虚拟内存地址空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#由来"><span class="nav-number">3.1.1.</span> <span class="nav-text">由来</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#介绍"><span class="nav-number">3.1.2.</span> <span class="nav-text">介绍</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分页存储管理"><span class="nav-number">3.2.</span> <span class="nav-text">分页存储管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分段存储管理"><span class="nav-number">3.3.</span> <span class="nav-text">分段存储管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#段页式存储"><span class="nav-number">3.4.</span> <span class="nav-text">段页式存储</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#逻辑地址，线性地址以及虚拟地址之间的关系"><span class="nav-number">4.</span> <span class="nav-text">逻辑地址，线性地址以及虚拟地址之间的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux内存分配算法-伙伴系统和slab"><span class="nav-number">5.</span> <span class="nav-text">linux内存分配算法:伙伴系统和slab</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#外部内存锁片"><span class="nav-number">5.1.</span> <span class="nav-text">外部内存锁片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伙伴系统"><span class="nav-number">5.2.</span> <span class="nav-text">伙伴系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部内存碎片"><span class="nav-number">5.3.</span> <span class="nav-text">内部内存碎片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slab高速缓存"><span class="nav-number">5.4.</span> <span class="nav-text">slab高速缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考"><span class="nav-number">5.5.</span> <span class="nav-text">参考</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Raoxiaoman</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
  

  
  
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>
  

  
  
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script>
  

  
  
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.min.js"></script>
  

  
  
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.ui.min.js"></script>
  

  
  
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	

		<script type="text/javascript">
		_hcwp = window._hcwp || [];

		_hcwp.push({widget:"Bloggerstream", widget_id: 102533, selector:".hc-comment-count", label: "{\%COUNT%\}" });

		
		_hcwp.push({widget:"Stream", widget_id: 102533, xid: "2018/03/15/linux-C-内存结构梳理/"});
		

		(function() {
		if("HC_LOAD_INIT" in window)return;
		HC_LOAD_INIT = true;
		var lang = (navigator.language || navigator.systemLanguage || navigator.userLanguage || "en").substr(0, 2).toLowerCase();
		var hcc = document.createElement("script"); hcc.type = "text/javascript"; hcc.async = true;
		hcc.src = ("https:" == document.location.protocol ? "https" : "http")+"://w.hypercomments.com/widget/hc/102533/"+lang+"/widget.js";
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(hcc, s.nextSibling);
		})();
		</script>

	
















  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
